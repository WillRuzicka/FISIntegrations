commonfields:
  id: Https_via_Credentials
  version: -1
vcShouldKeepItemLegacyProdMachine: false
name: Https_via_Credentials
display: Https_via_Credentials
category: Authentication & Identity Management
image: data:image/png;base64,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
description: 'This integration is intended to use the credentials store feature for
  https requests. Referencing the https_v2 script for functionality. '
detaileddescription: "1. Ensure you have valid credentials stored in XSOAR under the
  Credentials tab.\n2. When creating a new instance of the http request instance,
  use label called 'Credentials' and select the credentials you wish to use.\n3. When
  using within a playbook, you will be choosing the http_request command. \nYou MUST
  supply a valid url, method of request, and authentication type for the request to
  work. If the method of authentication isn't supplied, please use the 'N/A' option
  and use the 'headers' argument to supply proper means of authentication."
configuration:
- display: ""
  name: auth_credentials
  type: 9
  required: false
script:
  script: |
    register_module_line('Http_creds', 'start', __line__())
    ### from version: 8.8.0

    from typing import Dict, List
    import json
    from base64 import b64encode

    CONTENT_TYPE_MAPPER = {
        "json": "application/json",
        "xml": "text/xml",
        "form": "application/x-www-form-urlencoded",
        "data": "multipart/form-data"
    }

    RAW_RESPONSE = 'raw_response'


    class Client(BaseClient):
        def __init__(self, base_url: str, verify: bool, proxy: bool):

            super().__init__(base_url=base_url, verify=verify, proxy=proxy)

        def http_request(self, method: str, full_url: str = '', headers: dict = None, resp_type: str = RAW_RESPONSE,
                         params: dict = None, data: str = None, timeout: int = 10, retries: int = 0,
                         status_list_to_retry: list = None, allow_redirects: bool = True,
                         backoff_factor: int = 5):
            try:
                res = self._http_request(
                    method=method,
                    full_url=full_url,
                    headers=headers,
                    params=params,
                    timeout=timeout,
                    resp_type=resp_type,
                    status_list_to_retry=status_list_to_retry,
                    retries=retries,
                    data=data,
                    error_handler=self._generic_error_handler,
                    allow_redirects=allow_redirects,
                    backoff_factor=backoff_factor
                )
            except requests.exceptions.ConnectTimeout as exception:
                err_msg = 'Connection Timeout Error - potential reasons might be that the Server URL parameter' \
                          ' is incorrect or that the Server is not accessible from your host.'
                raise DemistoException(err_msg, exception)
            return res

        @staticmethod
        def _generic_error_handler(res: requests.Response):
            status_code = res.status_code
            if status_code == 400:
                raise DemistoException(f"Bad request. Status code: {status_code}. Origin response from server: {res.text}")

            if status_code == 401:
                raise DemistoException(f"Unauthorized. Status code: {status_code}. Origin response from server: {res.text}")

            if status_code == 403:
                raise DemistoException(f"Invalid permissions. Status code: {status_code}. "
                                       f"Origin response from server: {res.text}")

            if status_code == 404:
                raise DemistoException(f"The server has not found anything matching the request URI. Status code:"
                                       f" {status_code}. Origin response from server: {res.text}")
            if status_code == 500:
                raise DemistoException(f"Internal server error. Status code: {status_code}."
                                       f" Origin response from server: {res.text}")

            if status_code == 502:
                raise DemistoException(f"Bad gateway. Status code: {status_code}. Origin response from server: {res.text}")


    def create_headers(headers: Dict, request_content_type_header: str, response_content_type_header: str) \
            -> Dict[str, str]:
        """
        Create a dictionary of headers. It will map the header if it exists in the CONTENT_TYPE_MAPPER.
        Args:
            headers: The headers the user insert.
            request_content_type_header: The content type header.
            response_content_type_header: The response type header.

        Returns:
            A dictionary of headers to send in the request.
        """
        if request_content_type_header in CONTENT_TYPE_MAPPER.keys():
            request_content_type_header = CONTENT_TYPE_MAPPER[request_content_type_header]
        if response_content_type_header in CONTENT_TYPE_MAPPER.keys():
            response_content_type_header = CONTENT_TYPE_MAPPER[response_content_type_header]
        if request_content_type_header and not headers.get('Content-Type'):
            headers['Content-Type'] = request_content_type_header
        if response_content_type_header and not headers.get('Accept'):
            headers['Accept'] = response_content_type_header

        return headers


    def get_parsed_response(res, resp_type: str) -> Any:
        try:
            resp_type = resp_type.lower()
            if resp_type == 'json':
                res = res.json()
            elif resp_type == 'xml':
                res = json.loads(xml2json(res.content))
            else:
                res = res.text
            return res
        except ValueError as exception:
            raise DemistoException('Failed to parse json object from response: {}'
                                   .format(res.content), exception)


    def format_status_list(status_list: list) -> List[int]:
        """
        Get a status list and format it to a range of status numbers.
        Example:
            given: ['400-404',500,501]
            return: [400,401,402,403,500,501]
        Args:
            status_list: The given status list.
        Returns:
            A list of statuses to retry.
        """
        final_status_list = []
        for status in status_list:
            # Checks if the status is a range of statuses
            if '-' in status:
                range_numbers = status.split('-')
                status_range = list(range(int(range_numbers[0]), int(range_numbers[1]) + 1))
                final_status_list.extend(status_range)
            elif status.isdigit():
                final_status_list.append(int(status))
        return final_status_list


    def build_outputs(parsed_res, res: requests.Response) -> Dict:
        return {'ParsedBody': parsed_res,
                'Body': res.text,
                'StatusCode': res.status_code,
                'StatusText': res.reason,
                'URL': res.url,
                'Headers': dict(res.headers)}


    def parse_headers(headers: str) -> Dict:
        """
            Parsing headers from str type to dict.
            The allowed format are:
            1. {"key": "value"}
            2. "key": "value"
        """
        if not headers.startswith('{') and not headers.endswith('}'):
            headers = '{' + headers + '}'
        try:
            headers_dict = json.loads(headers)
        except json.decoder.JSONDecodeError:
            raise DemistoException("Make sure the headers are in one of the allowed formats.")
        return headers_dict

    def main():
        params = demisto.params()
        cred = params.get('auth_credentials',{})
        uName = cred.get('identifier','')

        if demisto.command() == 'test-module':
            return_results("The http request will use stored credentials labeled: " + uName)
        if demisto.command() == 'http_request':
            args = demisto.args()
            method = args.get('method', '')
            full_url = args.get('url', '')
            body = args.get('body', '')
            request_content_type = args.get('request_content_type', '')
            response_content_type = args.get('response_content_type', '')
            parse_response_as = args.get('parse_response_as', RAW_RESPONSE)
            params = params.get('params', {})
            headers = args.get('headers', {})
            authType = args.get('authType', {})
            passw = cred.get('password',{})
            token = b64encode(f"{uName}:{passw}".encode('utf-8')).decode("ASCII")

            if isinstance(headers, str):
                headers = parse_headers(headers)
            if authType!=('N/A'):
                headers["Authorization"] = authType + ' ' + token
            headers = create_headers(headers, request_content_type, response_content_type)

            save_as_file = args.get('save_as_file', 'no')
            file_name = args.get('filename', 'http-file')
            timeout = arg_to_number(args.get('timeout', 10))
            timeout_between_retries = args.get('timeout_between_retries', 5)
            retry_count = arg_to_number(args.get('retry_count', 3))
            proxy = argToBoolean(args.get('proxy', False))
            verify = argToBoolean(not args.get('unsecure', False))

            client = Client(base_url=full_url, verify=verify, proxy=proxy)
            kwargs = {
                'method': method,
                'full_url': full_url,
                'headers': headers,
                'data': body,
                'timeout': timeout,
                'params': params,
                'backoff_factor': timeout_between_retries
            }

            retry_on_status = args.get('retry_on_status', None)
            raise_on_status = True if retry_on_status else False
            retry_status_list = format_status_list(argToList(retry_on_status))

            if raise_on_status:
                kwargs.update({
                    'retries': retry_count,
                    'status_list_to_retry': retry_status_list,
                    'raise_on_status': raise_on_status
                })
            try:
                enable_redirect = argToBoolean(args.get('enable_redirect', True))

                if not enable_redirect:
                    kwargs.update({
                        'allow_redirects': enable_redirect
                    })

                res = client.http_request(**kwargs)
                parsed_res = get_parsed_response(res, parse_response_as)

                if save_as_file == 'yes':
                    return_results(fileResult(file_name, res.content))

                outputs = build_outputs(parsed_res, res)

                return_results(CommandResults(
                    readable_output=f"Sent a {method} request to {full_url}",
                    outputs_prefix='HttpRequest.Response',
                    outputs=outputs,
                    raw_response={'data': parsed_res}
                ))
            except Exception as e:
                return_error(f'Failed to execute HttpV2 script. Error: {str(e)}')

    #if demisto.command() == 'long-running-execution':
      # Should have here an endless loop

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('Http_creds', 'end', __line__())
  type: python
  commands:
  - name: http_request
    arguments:
    - name: headers
      description: 'Specify a hash of headers to send with the request. Headers can
        be of string type but need to be formatted in the following ways: `\{"key1":
        "value1", "key2": "value2"\}` or `"key1": "value1", "key2": "value2"`'
      isArray: true
    - name: proxy
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: Use system proxy settings
      defaultValue: "False"
    - name: unsecure
      auto: PREDEFINED
      predefined:
      - "False"
      - "True"
      description: Trust any certificate (not secure)
      defaultValue: "False"
    - name: filename
      description: Specify the name of file to be saved. Defaults to 'http-file'
      defaultValue: http-file
    - name: save_as_file
      auto: PREDEFINED
      predefined:
      - "yes"
      - "no"
      description: Save the response in a file.
      defaultValue: "no"
    - name: timeout_between_retries
      description: Specify the timeout between each retry in seconds. Defaults to
        5.
      defaultValue: "5"
    - name: retry_count
      description: Specify the number or retries to be made in case of a failure.
        Defaults to 3.
      defaultValue: "3"
    - name: enable_redirect
      auto: PREDEFINED
      predefined:
      - "True"
      - "False"
      description: The request will be called again with the new URL.
      defaultValue: "True"
    - name: timeout
      description: Specify the timeout of the HTTP request in seconds. Defaults to
        10 seconds.
      defaultValue: "10"
    - name: parse_response_as
      description: Specify how you would like to parse the response.
      defaultValue: raw_response
    - name: request_content_type
      description: 'Specify the Content-Type header for the request. Shorthands are
        provided for the following common content types: json (application/json) xml
        (text/xml) form (application/x-www-form-urlencoded) data (multipart/form-data)
        If you choose to define a different type, please include the full type name,
        e.g: application/pdf'
    - name: body
      description: Specify the body of the request.
    - name: method
      required: true
      auto: PREDEFINED
      predefined:
      - GET
      - POST
      - PUT
      - DELETE
      - PATCH
      - HEAD
      description: Specify the HTTP method to use.
    - name: url
      required: true
      description: Specify where the request should be sent. Include the URI scheme
        ('http' or 'https').
    - name: params
      description: URL parameters to specify the query.
    - name: authType
      required: true
      auto: PREDEFINED
      predefined:
      - Basic
      - N/A
      - Bearer
      description: Select or type your method of authentication. If no auth needed,
        select 'N/A'.
      defaultValue: Basic
    - name: response_content_type
      description: 'Specify the Accept header for the request - the response content
        type. Shorthands are provided for the following common content types: json
        (application/json) xml (text/xml) form (application/x-www-form-urlencoded)
        data (multipart/form-data) If you choose to define a different type, please
        include the full type name, e.g: application/pdf'
    outputs:
    - contextPath: HttpRequest.Response.URL
      type: unknown
    - contextPath: HttpRequest.Response.StatusCode
    - contextPath: HttpRequest.Response.StatusText
    - contextPath: HttpRequest.Response.ParsedBody
    - contextPath: HttpRequest.Response.Headers
    - contextPath: HttpRequest.Response.Body
    description: Perform an http request using XSOAR stored credentials.
  dockerimage: demisto/python3:3.11.10.116949
  runonce: false
  subtype: python3
  fromversion: 8.8.0